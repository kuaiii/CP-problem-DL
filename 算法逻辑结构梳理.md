# SDN 拓扑鲁棒性分析算法 - 逻辑结构梳理

## 一、整体架构概览

本系统是一个**双层优化框架**，用于解决SDN（软件定义网络）中的控制器部署问题，目标是在网络攻击下最大化网络鲁棒性。

### 核心思想
1. **第一层（拓扑层）**：优化网络拓扑结构，构建双峰度分布网络
2. **第二层（控制器部署层）**：在优化后的拓扑上，使用强化学习选择最优控制器位置

---

## 二、主要模块结构

```
main.py (主入口)
├── 参数解析 (parse_arguments)
├── 图加载/生成 (load_or_generate_graph)
├── 实验目录设置 (setup_experiment_dir)
└── 批量仿真 (run_simulation_batch)
    └── ControllerManager (控制器管理器)
        ├── 拓扑生成模块 (src/topology/)
        ├── 控制器选择模块 (src/controller/)
        ├── 攻击仿真模块 (src/simulation/)
        └── 指标评估模块 (src/metrics/)
```

---

## 三、详细算法流程

### 3.1 主流程 (main.py)

#### 步骤1: 初始化阶段
```python
1. 解析命令行参数 (--dataset, --attack, --rate, --batch_size)
2. 加载或生成网络拓扑
   - 从GML文件加载真实拓扑
   - 或生成BA无标度网络（合成数据）
3. 创建实验目录结构
   - results/{dataset}/{attack_mode}/{metric_type}/{experiment_id}/
```

#### 步骤2: 拓扑生成阶段 (run_simulation_batch)
为每次迭代生成多种对比拓扑：

| 拓扑 | 生成方法 | 说明 |
|------|---------|------|
| G (Baseline) | 原始拓扑 | 未优化的原始网络 |
| G1 (Random) | `construct_random()` | 随机重构，保持节点数和边数 |
| G2 (BA) | `construct_ba()` | 无标度网络重构 |
| G3 (Bimodal) | `create_bimodal_network_exact()` | **双峰度分布网络（核心）** |
| G4 (GA) | `construct_Three()` | 遗传算法优化 |
| G5 (Onion) | `construct_onion()` | Onion优化 |
| G6 (SOLO) | `construct_solo()` | SOLO优化 |
| G7 (ROMEN) | `construct_romen()` | ROMEN优化 |
| G8 (BimodalRL) | `construct_bimodal_rl()` | BimodalRL优化 |
| G9 (UNITY) | `construct_unity()` | UNITY优化 |

#### 步骤3: 控制器部署策略对比
对每种拓扑，应用不同的控制器选择策略：

| 方法名称 | 拓扑 | 控制器选择策略 | 说明 |
|---------|------|--------------|------|
| Baseline | G (原始) | 随机选择 | 基准方法 |
| RCP | G (原始) | E-RCP算法 | 传统优化方法 |
| Bi-level | G3 (双峰) | **RL选择** | **本文核心方法** |
| Bimodal+Random | G3 (双峰) | 随机选择 | 验证拓扑有效性 |
| Random+RL | G1 (随机) | RL选择 | 验证RL有效性 |
| GA+RL | G4 (GA) | RL选择 | 组合效果验证 |
| Onion+Ra | G5 (Onion) | 随机选择 | 对比方法 |
| Onion+RL | G5 (Onion) | RL选择 | 对比方法 |
| SOLO+Ra | G6 (SOLO) | 随机选择 | 对比方法 |
| SOLO+RL | G6 (SOLO) | RL选择 | 对比方法 |
| ROMEN+Ra | G7 (ROMEN) | 随机选择 | 对比方法 |
| ROMEN+RL | G7 (ROMEN) | RL选择 | 对比方法 |
| BimodalRL | G8 (BimodalRL) | RL选择 | 对比方法 |
| UNITY+Ra | G9 (UNITY) | 随机选择 | 对比方法 |
| UNITY+RL | G9 (UNITY) | RL选择 | 对比方法 |

#### 步骤4: 攻击仿真 (node_attack)
对每种"拓扑+控制器部署"组合，执行攻击仿真：

1. **生成攻击序列** (`get_dismantling_sequence`)
   - `random`: 随机攻击
   - `target`/`degree`: 自适应度攻击（每次移除度最大的节点）
   - `hybrid`: 混合攻击（20%概率度攻击，80%随机）
   - `pagerank`: PageRank中心性攻击
   - `betweenness`: 介数中心性攻击
   - `eigenvector`: 特征向量中心性攻击
   - `bruteforce`: 暴力枚举（仅小网络）

2. **模拟拆解过程** (`simulate_dismantling`)
   ```
   对于攻击序列中的每个节点：
   a. 移除节点及其边
   b. 如果移除的是控制器，触发级联失效：
      - 检查所有连通分量
      - 移除没有控制器的连通分量中的所有节点
   c. 计算当前网络指标：
      - LCC (极大连通子图占比)
      - CSA (控制供给可用性)
      - CCE (控制熵)
      - WCP (加权控制势能)
   d. 记录指标随移除比例的变化曲线
   e. 当LCC降至20%时，记录崩溃点并终止
   ```

#### 步骤5: 指标计算与评估

**核心指标：**
- **LCC (Largest Connected Component)**: 极大连通子图节点数 / 初始节点数
- **CSA (Control Supply Availability)**: `1/|V_S| * Σ(1 - e^(-α*k_i))`
  - k_i: 节点i所在连通分量中的控制器数量
- **CCE (Control Entropy)**: `-Σ(p_j * ln(p_j))`
  - p_j: 控制器j的服务域占比
- **WCP (Weighted Control Potential)**: `1/|V_S| * Σ_i Σ_j (1/d_ij^β)`
  - d_ij: 节点i到控制器j的最短距离

**鲁棒性指标：**
- **R (Robustness)**: LCC曲线下的面积（使用梯形法则计算）
- **崩溃点 (Collapse Point)**: LCC降至20%时的节点移除比例

#### 步骤6: 结果保存与可视化
- 保存CSV数据（x_values, r_values, 统计数据）
- 生成图表（曲线图、柱状图、箱线图）
- 保存每次迭代的详细指标曲线

---

## 四、核心算法详解

### 4.1 双峰拓扑构建 (Bimodal Network Construction)

**目标**: 构建具有双峰度分布的网络，其中：
- **Hub节点**（高度节点）: 作为控制器的候选位置
- **Leaf节点**（低度节点）: 普通交换节点

**数学约束**:
```
k1 * kmax + k2 * kmin = 2 * m  (度守恒)
k1 + k2 = n                     (节点数守恒)
```

其中：
- k1: Hub节点数量（通常 = ceil(n * rate)）
- k2: Leaf节点数量
- kmax: Hub节点的度
- kmin: Leaf节点的度
- m: 边数
- n: 节点数

**实现**: `create_bimodal_network_exact()` (src/topology/reconstruction.py)

### 4.2 强化学习控制器选择 (RL-based Controller Selection)

**策略网络**: MLP (多层感知机)
- **输入特征**: 节点度、聚类系数、介数中心性
- **输出**: 每个节点被选为控制器的概率

**训练过程** (`train_and_select`):
1. 加载预训练模型（如果存在）
2. 对当前拓扑进行在线微调（可选）
3. 使用策略网络选择控制器：
   - 采样节点特征
   - 通过策略网络得到选择概率
   - 使用K-Median算法优化最终选择

**奖励函数**: 基于鲁棒性指标（robustness metric）

**实现**: `src/controller/rl_optimizer.py`

### 4.3 级联失效机制 (Cascade Failure)

**触发条件**: 当攻击移除一个控制器节点时

**失效规则**:
```
对于每个连通分量：
  如果该分量中没有任何控制器：
    移除该分量中的所有节点
```

这模拟了SDN中交换机失去控制器连接后的失效行为。

**实现**: `simulate_dismantling()` (src/simulation/dismantling.py)

---

## 五、数据流图

```
原始拓扑 G
    ↓
[拓扑优化层]
    ├─→ G1 (Random)
    ├─→ G2 (BA)
    ├─→ G3 (Bimodal) ← 核心
    ├─→ G4 (GA)
    ├─→ G5 (Onion)
    ├─→ G6 (SOLO)
    ├─→ G7 (ROMEN)
    ├─→ G8 (BimodalRL)
    └─→ G9 (UNITY)
    ↓
[控制器部署层]
    ├─→ 随机选择
    ├─→ E-RCP算法
    └─→ RL选择 ← 核心
    ↓
[攻击仿真层]
    ├─→ 生成攻击序列
    ├─→ 逐步移除节点
    ├─→ 级联失效检测
    └─→ 指标计算
    ↓
[评估层]
    ├─→ LCC曲线
    ├─→ CSA/CCE/WCP曲线
    ├─→ 鲁棒性R值
    └─→ 崩溃点
    ↓
结果保存与可视化
```

---

## 六、关键设计决策

### 6.1 为什么使用双峰拓扑？
- **Hub节点集中度高**: 便于控制器集中部署，提高控制效率
- **Leaf节点分散**: 降低单点故障风险
- **度分布优化**: 在保持总边数不变的情况下，最大化Hub-Leaf连接

### 6.2 为什么使用RL而非传统优化？
- **适应性强**: RL可以学习不同拓扑的特征模式
- **端到端优化**: 直接优化鲁棒性指标，而非中间指标
- **可扩展性**: 易于扩展到更复杂的网络结构

### 6.3 为什么使用多种攻击模式？
- **鲁棒性评估**: 不同攻击策略测试不同方面的鲁棒性
- **现实性**: 模拟真实网络攻击场景（随机攻击、针对性攻击、混合攻击）

---

## 七、实验配置

### 7.1 默认参数
- **控制器部署率**: `rate = 0.1` (10%的节点作为控制器)
- **批量大小**: `batch_size = 1` (可配置多次运行取平均)
- **攻击模式**: `random` (可配置为 target, hybrid, degree, pagerank等)
- **评估指标**: `lcc` (主要指标，同时计算 csa, cce, wcp)

### 7.2 输出结构
```
results/
└── {dataset_name}/
    └── {attack_mode}/
        ├── lcc/              # LCC指标结果
        ├── csa/              # CSA指标结果
        ├── cce/              # CCE指标结果
        ├── wcp/              # WCP指标结果
        └── {experiment_id}/
            ├── logs/         # 日志文件
            ├── *.csv         # 数据文件
            ├── *.png         # 图表文件
            └── extradata/    # 每次迭代的详细曲线
```

---

## 八、算法复杂度分析

### 8.1 时间复杂度
- **拓扑生成**: O(n²) - O(n³) (取决于优化算法)
- **RL控制器选择**: O(n * k) (k为控制器数量)
- **攻击仿真**: O(n * m) (m为边数，每次移除需重新计算连通分量)
- **指标计算**: O(n²) (最短路径计算)

### 8.2 空间复杂度
- **图存储**: O(n + m)
- **距离矩阵**: O(n²) (部分算法需要)
- **RL模型**: O(模型参数数量)

---

## 九、扩展点

1. **新的拓扑优化算法**: 在 `src/topology/` 中添加新的构造函数
2. **新的控制器选择策略**: 在 `src/controller/strategies.py` 中添加
3. **新的攻击模式**: 在 `src/simulation/dismantling.py` 中添加
4. **新的评估指标**: 在 `src/metrics/metrics.py` 中添加计算函数

---

## 十、总结

本系统实现了一个**双层优化框架**：
1. **拓扑层**: 通过双峰度分布优化网络结构
2. **部署层**: 通过强化学习优化控制器位置

通过多种对比实验，验证了该方法的有效性，并在多种攻击场景下评估了网络鲁棒性。
